import os
from abc import ABC, abstractmethod
import django
from django.db import connection


from schema import table_queries

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")
django.setup()


class SchemaManager:
    def test_connection(self):
        test_query = "SELECT current_database();"
        try:
            with connection.cursor() as cursor:
                cursor.execute(test_query)
                return True if cursor.fetchone()[0] else False
        except Exception:
            return False
    
    def create_table(self, table_name, query):
        if not self.test_connection():
            return "Error: Couldn`t connect to the database."
        
        try:
            with connection.cursor() as cursor:
                cursor.execute(query)
            connection.commit()
            return f"Table: {table_name} created successfully."
            
        except Exception as e:
            connection.rollback()
            return f"Error: Unable to create table. {e}"
    
    def drop_table(self, table_name):        
        if not self.test_connection():
            return "Error: Couldn`t connect to the database."
        
        try:
            with connection.cursor() as cursor:
                cursor.execute(f"DROP TABLE IF EXISTS {table_name} CASCADE;")
            connection.commit()
            return f"Table:{table_name} deleted successfully."
            
        except Exception as e:
            connection.rollback()
            return f"Error: Unable to delete table. {e}"


class Table(ABC):
    table_name = None
    fields = None
    required_fields = None
    
    def __init__(self):
        ...#self.table_name = self.__class__.__name__.lower()
    
    @abstractmethod
    def abstract_table(self):
        '''This method is only mentioned to make this class abstract.'''
        pass
    
    def count(self):
        pass
    
    def all(self):
        query = f"SELECT * FROM {self.table_name}"
        try:
            with connection.cursor() as cursor:
                cursor.execute(query)
                result = cursor.fetchall()
                return result
        except Exception as e:
            return f"Error: {e}"
            
    def get(self, column: dict):        
        conditions = None
        query = f"SELECT * FROM {self.table_name} WHERE id=3;"
        try:
            with connection.cursor() as cursor:
                cursor.execute(query)
                result = cursor.fetchone()
                return result
        except Exception as e:
            return f"Error: {e}"
    
    def filter(self):
        pass
    
    def create(self, values:dict): 
        ''' There won`t ever be all fields to insert in the table as some fields will be generated by dB '''
        cols = ", ".join(list(values.keys()))
        vals = tuple(values.values())
        placeholders = ", ".join(['%s' for values in vals])
        
        query = f"INSERT INTO {self.table_name} ({cols}) VALUES ({placeholders});"
        
        try:
            with connection.cursor() as cursor:
                cursor.execute(query, vals)
            connection.commit()
            return f"Record inserted successfully in the {self.table_name}."
        except Exception as e:
            return f"Error: {e}"
        
    def update(self):
        pass
    
    def delete(self, id:int):
        query = f"DELETE FROM {self.table_name} WHERE id = %s"
        
        try:
            with connection.cursor() as cursor:
                cursor.execute(query, (id,))
            connection.commit()
            return f"Record deleted successfully from the {self.table_name}."
        
        except Exception as e:
            return f"Error: {e}"
            


if __name__ == "__main__":
    print(Table().__dict__)     
    
